"""
gene.py realize the methods that are related to system recommendation.

@author: Bowen
"""

from system.models import gene, reaction, compound, reaction_compound, compound_gene, pathway, pathway_compound, organism
from system.fasta_reader import parse_fasta_str
from elasticsearch import Elasticsearch
import traceback
import urllib2
import json
from django.db.models import Q

def search_compound(keyword):
    """
    search compound based on the keyword

    @param keyword: the keyword that the user typed. Which would be used in search
    @type keyword: str
    @return: return a list that contains searched compounds
    @rtype: list
    """

    es = Elasticsearch()
    result = format_fuzzy_result(fuzzy_search_compound(es, keyword))
    return result

def fuzzy_search_compound(es, keyword):
    """
    fuzzy search compound based on the keyword with elasticsearch

    @param es: the elasticsearch object
    @param keyword: the search keyword
    @type es: Elasticsearch
    @type keyword: str
    @return a dict generated by the elasticsearch, which contains the search result
    @rtype: dict
    """

    query_body = {
        "from" : 0,
        "size" : 20,
        "query" : {
            "fuzzy_like_this" : {
                "fields" : ["name"],
                "like_text" : keyword,
                "max_query_terms" : 20
            }
        }
    }
    result = es.search(index="biodesigners", doc_type="compounds", body=query_body)
    return result

def format_fuzzy_result(es_result):
    """
    format the es search result to front end processable format

    @param es_result: the es search result
    @type es_result: dict
    @return: the front end processable format, while will be like this::
        [{'compound_id': id, 'name': name},...]
    @rtype: list
    """

    compound_result = es_result['hits']['hits']
    result = list()
    if len(compound_result) != 0:
        for compound_item in compound_result:
            info = compound_item['_source']
            compound_info = {
                'compound_id': info["compound_id"],
                'name': info['name'],
            }
            result.append(compound_info)
    return result

def get_gene_info(gid):
    try:
        gene_obj = gene.objects.get(gene_id=gid)
        result = {
            'gene_id': gene_obj.gene_id,
            'name': gene_obj.name,
            'definition': gene_obj.definition,
            'organism_short': gene_obj.organism_short,
            'organism': gene_obj.organism
        }
        return True, result
    except:
        traceback.print_exc()
        return False, None

def get_compound_info(cid):
    """
    get a specific compound's information

    @param cid: compound id
    @type cid: str
    @return: a tunple that contains is compound can be retrived and the information
    @rtype: dict
    """

    try:
        compound_obj = compound.objects.get(compound_id=cid)
        result = {
            'compound_id' : compound_obj.compound_id,
            'name': compound_obj.name,
            'nicknames' : compound_obj.nicknames.replace('_', '\n'),
            'formula' : compound_obj.formula,
            'exact_mass' : compound_obj.exact_mass,
            'mol_weight' : compound_obj.mol_mass
        }
        return True, result
    except:
        traceback.print_exc()
        return False, None

def retrive_gene_detain(gid):
    #get information from ncbi
    baseUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=gene&retmode=json&version=2.0&id='
    req = urllib2.Request(baseUrl + gid)
    response = urllib2.urlopen(req)
    resStr = response.read()
    result = json.loads(resStr)
    infos = result['result'][gid]
    detail_info = dict()
    detail_info['name'] = infos['name']
    detail_info['definition'] = infos['description']
    detail_info['organism'] = infos['organism']['scientificname']
    return detail_info

def get_or_create_gene(gid):
    #get in database
    try:
        gene_obj = gene.objects.get(gene_id=gid)
        return gene_obj
    except:
        #get from ncbi
        baseUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&rettype=fasta&id='
        req = urllib2.Request(baseUrl + gid)
        response = urllib2.urlopen(req)
        resStr = response.read()
        gene_dict = parse_fasta_str(resStr)
        for gn in gene_dict.keys():
            gid = gn.split('|')[1]
            #get detail information
            new_gene_obj = gene(gene_id=gid)
            detail_info = retrive_gene_detain(gid)
            new_gene_obj.name = detail_info['name']
            new_gene_obj.definition = detail_info['definition']
            new_gene_obj.organism = detail_info['organism']
            new_gene_obj.ntseq = gene_dict[gn]
            new_gene_obj.ntseq_length = len(gene_dict[gn])
            try:
                new_gene_obj.save()
                return new_gene_obj
            except:
                pass
        return None


def save_relation_to_db(geneIdList, compound_obj):
    #create new obj
    for gid in geneIdList:
        new_rela_obj = compound_gene(compound=compound_obj)
        gene_obj = get_or_create_gene(gid)
        new_rela_obj.gene = gene_obj
        try:
            new_rela_obj.save()
        except:
            pass

def search_gene_in_ncbi(name, expect=None, index=0):
    #find in database
    compound_obj = None
    try:
        compound_obj = compound.objects.get(name=name)
    except:
        compound_obj = get_compound(name)
    if compound_obj == None:
        return None
    obj_list = compound_gene.objects.filter(compound=compound_obj)
    if len(obj_list) != 0:
        geneIdList = list()
        for obj in obj_list:
            geneIdList.append(obj.gene.gene_id)
        return geneIdList[:5]
    #retrive from kegg
    baseGeneFindUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=gene&retmode=json&term='
    try:
        req = urllib2.Request(baseGeneFindUrl + name)
        response = urllib2.urlopen(req)
        resStr = response.read()
    except:
        traceback.print_exc()
        return None
    if len(resStr) == 0:
        return None
    result = json.loads(resStr)
    geneIdList = result['esearchresult']['idlist']
    save_relation_to_db(geneIdList, compound_obj)
    if expect != None:
        try:
            del geneIdList[geneIdList.index(expect)]
        except:
            pass
    return geneIdList[:2]

class gene_graph:
    def __init__(self, cid_list, ogm):
        if cid_list.startswith('_'):
            cid_list = cid_list[1:]
        if cid_list.endswith('_'):
            cid_list = cid_list[:-1]
        self.cid_list = cid_list.split('_')
        self.nodes = list()
        self.edges = list()
        self.index_dict = dict()
        self.index = 0
        if ogm != None:
            if ogm.startswith('_'):
                ogm = ogm[1:]
            if ogm.endswith('_'):
                ogm = ogm[:-1]
            self.organisms = ogm.split('_')
        else:
            self.organisms = None


    def get_compound_object(self, cid):
        try:
            compound_obj = compound.objects.get(compound_id=cid)
            return compound_obj
        except:
            return None

    def retrive_gene_detain(self, gid):
        #get information from ncbi
        baseUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=gene&retmode=json&version=2.0&id='
        
        try:
            req = urllib2.Request(baseUrl + gid)
            response = urllib2.urlopen(req)
            resStr = response.read()
            result = json.loads(resStr)
            infos = result['result'][gid]
            detail_info = dict()
            detail_info['name'] = infos['name']
            detail_info['definition'] = infos['description']
            detail_info['organism'] = infos['organism']['scientificname']
            return detail_info
        except:
            traceback.print_exc()
            return None

    def related_compound(self, cid):
        compound_obj = self.get_compound_object(cid)
        if self.organisms != None:
            organism_pathway_id_list = pathway.objects.filter(organism_id__in=self.organisms).values_list('pathway_id', flat=True)
        else:
            organism_pathway_id_list = pathway.objects.all()
        valued_pathway_id_list = pathway_compound.objects.filter(pathway_id__in=organism_pathway_id_list, compound=compound_obj)
        valued_compound_list = pathway_compound.objects.filter(Q(pathway_id__in=valued_pathway_id_list), ~Q(compound=compound_obj)).values_list('compound', flat=True)
        compound_list = compound.objects.filter(compound_id__in=valued_compound_list)
        return compound_list

    def create_node(self, name, id):
        node_info = {
            'name': name,
            'id': id
        }
        self.nodes.append(node_info)
        if id in self.index_dict.keys():
            return True
        self.index_dict[id] = self.index
        self.index += 1
        return True

    def create_n_link(self, center_node, compound_obj):
        gene_list = self.search_gene(compound_obj)
        for gene_id in gene_list:
            try:
                gene_obj = gene.objects.get(gene_id=gene_id)
                if self.create_node(gene_obj.name, gene_obj.gene_id):
                    edge_info = {
                        'source' : self.index_dict[center_node],
                        'target' : self.index_dict[gene_obj.gene_id],
                        'relation' : compound_obj.name
                    }
                    self.edges.append(edge_info)
            except:
                traceback.print_exc()
                pass
        return gene_list[0]

    def get_or_create_gene(self, gid):
    #get in database
        try:
            gene_obj = gene.objects.get(gene_id=gid)
            return gene_obj
        except:
            #get from ncbi
            baseUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&rettype=fasta&id='
            req = urllib2.Request(baseUrl + gid)
            response = urllib2.urlopen(req)
            resStr = response.read()
            gene_dict = parse_fasta_str(resStr)
            for gn in gene_dict.keys():
                gid = gn.split('|')[1]
                #get detail information
                new_gene_obj = gene(gene_id=gid)
                detail_info = self.retrive_gene_detain(gid)
                if detail_info == None:
                    continue
                new_gene_obj.name = detail_info['name']
                new_gene_obj.definition = detail_info['definition']
                new_gene_obj.organism = detail_info['organism']
                new_gene_obj.ntseq = gene_dict[gn]
                new_gene_obj.ntseq_length = len(gene_dict[gn])
                try:
                    new_gene_obj.save()
                    return new_gene_obj
                except:
                    pass
            return None

    def save_relation_to_db(self, geneIdList, compound_obj):
    #create new obj
        for gid in geneIdList:
            new_rela_obj = compound_gene(compound=compound_obj)
            gene_obj = self.get_or_create_gene(gid)
            if gene_obj == None:
                continue
            new_rela_obj.gene = gene_obj
            try:
                new_rela_obj.save()
            except:
                pass

    def search_gene(self, compound_obj):
        #search in database
        obj_list = compound_gene.objects.filter(compound=compound_obj)
        if len(obj_list) != 0:
            geneIdList = list()
            for obj in obj_list:
                geneIdList.append(obj.gene.gene_id)
            return geneIdList[:2]
        else:
            baseGeneFindUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=gene&retmode=json&term='
            try:
                req = urllib2.Request(baseGeneFindUrl + compound_obj.name)
                response = urllib2.urlopen(req)
                resStr = response.read()
            except:
                traceback.print_exc()
                return None
            if len(resStr) == 0:
                return None
            result = json.loads(resStr)
            geneIdList = result['esearchresult']['idlist']
            self.save_relation_to_db(geneIdList, compound_obj)
            return geneIdList[:2]

    def cal_graph(self):
        for cid in self.cid_list:
            center_compound_obj = self.get_compound_object(cid)
            if center_compound_obj == None:
                continue
            self.create_node(center_compound_obj.name, center_compound_obj.compound_id)
            related_list = self.related_compound(center_compound_obj.compound_id)[:5]
            for compound_obj in related_list:
                new_center = self.create_n_link(center_compound_obj.compound_id, compound_obj)
                self.create_node(compound_obj.name, compound_obj.compound_id)
                edge_info = {
                    'source': self.index_dict[center_compound_obj.compound_id],
                    'target': self.index_dict[compound_obj.compound_id],
                    'relation': compound_obj.name,
                }
                deep_related_list = self.related_compound(compound_obj.compound_id)[:2]
                for deep_compound_obj in deep_related_list:
                    self.create_n_link(compound_obj.compound_id, deep_compound_obj)
        print self.index_dict

    def get_graph(self):
        result = {
            'nodes': self.nodes,
            'edges' : self.edges
        }
        return result



'''
def find_related_compound(cid_str):
    """
    find the compound that are related to current compound in reaction

    @param cid: list of compound id
    @type cid: list 
    @return: dict of compound that are related to the compound, empty list will be returned if there is no related compound
    @rtype: dict
    """
    result = dict()
    nodes = list()
    edges = list()
    all_genes = list()
    index_dict = dict()
    index = 0
    if cid_str.endswith('_'):
        cid_str = cid_str[:-1]
    cid_list = cid_str.split('_')
    for cid in cid_list:
        try:
            compound_obj = compound.objects.get(compound_id=cid)
            #get first gene and create new node
            cen_gene_id = None
            try:
                cen_gene_id = search_gene_in_ncbi(compound_obj.name,)[0]
                if not cen_gene_id in all_genes:
                    all_genes.append(cen_gene_id)
                    gene_obj = gene.objects.get(gene_id=cen_gene_id)
                    node_info = {
                        'name': gene_obj.name,
                        'id': gene_obj.gene_id
                    }
                    nodes.append(node_info)
                    index_dict[cen_gene_id] = index
                    index += 1
            except:
                pass
            # find related reactions
            rid_list = reaction_compound.objects.filter(compound=compound_obj, isReactant=True).values_list('reaction_id', flat=True)
            cname_list = list()
            for rid in rid_list:
                rs = reaction_compound.objects.filter(Q(reaction_id=rid), ~Q(compound=compound_obj))[:5]
                for r in rs:
                    cname_list.append(r.compound.name)
            for cname in cname_list:
                # find genes
                gene_list = search_gene_in_ncbi(cname, expect=cen_gene_id, index=1)
                for gene_id in gene_list:
                    if gene_id in all_genes:
                        continue
                    try:
                        gene_obj = gene.objects.get(gene_id=gene_id)
                        #create new node
                        all_genes.append(gene_id)
                        node_info = {
                            'name' : gene_obj.name,
                            'id': gene_obj.gene_id
                        }
                        nodes.append(node_info)
                        index_dict[gene_obj.gene_id] = index
                        index += 1
                        # add edge
                        edge_info = {
                            'source': index_dict[cen_gene_id],
                            'target': index_dict[gene_obj.gene_id],
                            'relation': cname
                        }
                        edges.append(edge_info)
                    except:
                        traceback.print_exc()
                        pass
        except:
            traceback.print_exc()
            pass
    result = {
        'nodes': nodes,
        'edges': edges
    }
    return result
'''